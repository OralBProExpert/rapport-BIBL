\section{Construire des arbres d'attaque pertinents}

\subsection{Approches de génération d'arbres d'attaque}

Le survey \cite{konsta2024computers} propose un panorama des différentes approches de génération automatique des modèles graphiques de sécurité. Ces méthodes diffèrent principalement par la manière dont les vulnérabilités du système sont détectées. On peut distinguer trois grandes catégories d'approches : l'analyse statique, la recherche d'atteignabilité dans un graphe, et le model checking. Ces méthodes prennent en entrée une description du système, ainsi qu'un objectif d'attaque, et produisent en sortie un arbre d'attaque représentant les différentes façons dont un attaquant peut atteindre cet objectif.

\subsubsection{Génération d'AT par avec l'algèbre de processus}

% TODO: Expliquer ce que c'est que analyse statique
La méthode introduite dans \cite{vigo2014process} est l’une des premières à proposer une génération automatique d’arbres d’attaque à partir d’un modèle formel. Le système étudié est représenté dans le cadre du \emph{Value Passing Calculus} \cite{nielson2012calculus}, qui permet de décrire les composants du système comme des processus capables d’échanger des informations. Cette approche ne dépend que d'un modèle du système, sans nécessiter d’informations supplémentaires sur les vulnérabilités ou les propriétés de sécurité. Elle rentre donc dans la catégorie des approches Model-Driven.

Dans cette approche, chaque interaction possible avec le système peut être interprétée comme une étape conditionnée par une forme de contrôle de sécurité. Autrement dit, certaines actions ne deviennent accessibles que si l’attaquant dispose des informations nécessaires.

On peut illustrer cela par un exemple simple : supposons qu’un coffre protégé par un code contienne une clé permettant d’ouvrir une porte sécurisée. Tant que l’adversaire ne connaît pas le code du coffre, il ne peut pas récupérer la clé, et donc ne peut pas accéder à la porte suivante. L’attaque complète consiste alors en une succession d’éléments à obtenir : d’abord le code, ensuite la clé, puis enfin l’ouverture de la porte.

De manière analogue, dans le modèle de \cite{vigo2014process}, ces informations indispensables sont représentées par des canaux de communication. Accéder à un comportement particulier du système revient à posséder la connaissance des canaux appropriés, comme un attaquant doit posséder les bons secrets ou accès pour progresser dans son attaque.

Une fois le modèle du système et l'objectif de l'attaque spécifiés, une formule propositonnelle est inférée, dépendant de propositions atomiques représentant la compromission ou la possession par l'attaquant de ressources, de secrets ou de capacités élémentaires du système. Un AT action-based est finalement inféré de cette formule.

Une fois le modèle du système et l'objectif de l'attaque spécifiés, la génération d'repose sur une méthode d'inférence logique permettant d'identifier les différentes combinaisons d'actions que l'attaquant peut entreprendre pour atteindre son objectif. Le résultat de cette inférence est une formule propositionnelle, dépendant de propositions atomiques représentant la compromission ou la possession par l'attaquant de ressources, de secrets ou de capacités élémentaires du système. Un AT state-based est finalement construit à partir de cette formule.

\vspace{0.2cm}

Bien que la complexité théorique soit exponentielle dans le pire des cas, ce coût dépend de la structure du processus et n’est pas systématique, contrairement à la vérification de modèles basée sur l’exploration de l’espace d’états.

\subsubsection{Génération d'AT par atteignabilité dans un graphe}

\subsubsection{Génération d'AT par model checking}

% \textcolor{OliveGreen}{Sous-section trop longue ?}

Parler des 3 catégories d'approches de génération d'arbres d'attaque \cite{konsta2024computers}
  
\cite{gadyatskaya2017refinement} : Règles de raffinement déduites du système, mais non labellisées par des objectifs réels. Approche de génération top-down permise par leurs règles générées mais ne marche pas si un expert spécifie une librairie. Limitée à $\mathrm{OR}$ et $\mathrm{SAND}$
  % \textcolor{OliveGreen}{Je ne sais pas trop quoi dire sur le fait que leurs règles de génération de règles de raffinement sont discutables, que l'algoritme de génération de ces règles n'est pas présenté, et qu'il n'y a pas d'analyse de complexité sans être cassant} 

\subsection{Guided design of attack trees}

Parler des techniques permettant de créer un arbre d'attaque correct et utile \cite{audinot2017correct, audinot2018guided}

Ouvrir sur la sous-section suivante -- comment raffiner une feuille quand on sait qu'elle est utile.

\subsection{Library-based attack tree synthesis}

Présentation de l'algorithme, approche bottom up \cite{pinchinat2020library}

Parler de l'extension de cette approche avec le langage étendu au shuffle.

% \textcolor{OliveGreen}{Redondant avec la 3.1 ?}

