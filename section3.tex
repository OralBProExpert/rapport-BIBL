\section{Construire des arbres d'attaque pertinents}

\subsection{Approches de génération d'arbres d'attaque}

Le survey \cite{konsta2024computers} propose un panorama des différentes approches de génération automatique des modèles graphiques de sécurité. Ces méthodes diffèrent principalement par la manière dont les vulnérabilités du système sont détectées. On peut distinguer trois grandes catégories d'approches : l'analyse syntaxique, la recherche d'atteignabilité dans un graphe, et le model checking. Ces méthodes prennent en entrée une description du système, ainsi qu'un objectif d'attaque, et produisent en sortie un arbre d'attaque représentant les différentes façons dont un attaquant peut atteindre cet objectif.

\subsubsection{Génération d'AT par analyse syntaxique du système}

% TODO: Expliquer ce que c'est que analyse syntaxique (peut-être trouver un meilleur terme en français ?) 
La méthode introduite dans \cite{vigo2014process} est l’une des premières à proposer une génération automatique d’arbres d’attaque. Le système étudié est représenté dans le cadre du \emph{Value Passing Calculus} \cite{nielson2012calculus}, une extension du $\pi$-calculus, qui permet de décrire les composants du système comme des \textit{processus} inter-communicants.

\vspace{0.2cm}

Dans cette approche, chaque interaction possible avec le système peut être interprétée comme une étape conditionnée par une forme de contrôle de sécurité. Autrement dit, certaines actions ne deviennent accessibles que si l’attaquant dispose des informations nécessaires.

Ces informations sont représentées par des \textit{canaux de communication}. Accéder à un comportement particulier du système revient à posséder la connaissance des canaux appropriés, tout comme un attaquant doit posséder les bons secrets ou accès pour progresser dans son attaque.

Une fois le modèle du système et l'objectif de l'attaque spécifiés, une formule propositonnelle est inférée à l’aide d’une approche de type chaînage arrière (backward chaining). Cette formule dépend des propositions atomiques qui représentent la compromission ou la possession par l'attaquant de ressources, de secrets ou de capacités élémentaires du système. Un AT action-based est finalement inféré de cette formule.
% TODO: Préciser ressources, de secrets ou de capacités élémentaires du système.

\vspace{0.2cm}

Cette approche constitue une limite, car elle fournit une sous-approximation des attaques réelles due au niveau d’abstraction du $\pi$-calcul, qui modélise la connaissance des canaux mais pas l’usage répété de ceux-ci. L’analyse indique ainsi quels canaux doivent être devinés, sans prendre en compte le nombre d’interactions nécessaires, ce qui peut conduire à sous-estimer l’effort réel de l’attaque.

Bien que la complexité théorique soit exponentielle dans le pire des cas, ce coût dépend de la structure du processus et n’est pas systématique, contrairement à la vérification de modèles basée sur l’exploration de l’espace d’états.

\subsubsection{Génération d'AT par atteignabilité dans un graphe}

On peut regrouper les approches de \cite{hong2013scalable}, et du projet européen TREsPASS \cite{ivanova2015attack, ivanova2016transforming} dans cette catégorie. 

\vspace{0.2cm}

La méthode présentée dans \cite{hong2013scalable} prend en entrée un système décrit sous forme d'un graphe orienté, où une attaque est un chemin menant d'un nœud initial $s$ à un nœud cible $t$. Tous les chemins de $s$ à $t$ sont extraits à l'aide d'une recherche en profondeur (depth-first search) depuis $t$, puis convertis en un arbre d'attaque en regroupant les sous-chemins communs.

\vspace{0.2cm}

Le projet TREsPASS \cite{ivanova2015attack, ivanova2016transforming} propose une approche similaire, mais en labellisant les nœuds du graphe avec des propriétés informations supplémentaires. Un nœud peut représenter \textit{endroit}, un \textit{acteur}, un \textit{processus} ou un \textit{objet}, et peut contenir des \textit{ressources}, qui peuvent être des \textit{objets}, ou des \textit{données}. Les conditions selon lesquelles des actions peuvent être réalisées par des acteurs ou des processus sont définies par des politiques. Une politique peut exiger des identifiants, constitués de données, d’objets ou de prédicats.

Les arbres d’attaque générés dans ce travail décrivent les moyens par lesquels un attaquant peut invalider une politique dans un système donné. Leur construction repose sur une invalidation récursive des politiques \cite{kammueller2013invalidating, kammueller2014combining}, consistant à identifier les acteurs potentiels ainsi que les couples action–localisation conduisant à l’invalidation de la politique.

Ces deux approches identifient les scénarios d'attaque par exploration de chemins dans un graphe représentant le système. Cependant, elles restent limitées en termes de généralisation. Elles nécessitent un graphe du système dans un formalisme spécifique, souvent différent d’un travail à l’autre, ce qui restreint la réutilisabilité des modèles. De plus, leur complexité est exponentielle dans le pire des cas, en raison de l’exploration exhaustive des chemins possibles entre les nœuds source et cible.

\subsubsection{Génération d'AT par model checking}

% \textcolor{OliveGreen}{Sous-section trop longue ?}

Parler des 3 catégories d'approches de génération d'arbres d'attaque \cite{konsta2024computers}
  
\cite{gadyatskaya2017refinement} : Règles de raffinement déduites du système, mais non labellisées par des objectifs réels. Approche de génération top-down permise par leurs règles générées mais ne marche pas si un expert spécifie une librairie. Limitée à $\mathrm{OR}$ et $\mathrm{SAND}$
  % \textcolor{OliveGreen}{Je ne sais pas trop quoi dire sur le fait que leurs règles de génération de règles de raffinement sont discutables, que l'algoritme de génération de ces règles n'est pas présenté, et qu'il n'y a pas d'analyse de complexité sans être cassant} 

\subsection{Guided design of attack trees}

Parler des techniques permettant de créer un arbre d'attaque correct et utile \cite{audinot2017correct, audinot2018guided}

Ouvrir sur la sous-section suivante -- comment raffiner une feuille quand on sait qu'elle est utile.

\subsection{Library-based attack tree synthesis}

Présentation de l'algorithme, approche bottom up \cite{pinchinat2020library}

Parler de l'extension de cette approche avec le langage étendu au shuffle.

